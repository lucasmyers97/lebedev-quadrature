#ifndef OCTAHEDRAL_GENERATOR
#define OCTAHEDRAL_GENERATOR

#include <vector>
#include <cassert>
#include <stdexcept>

namespace lebedev {

using vec = std::vector<double>;

enum class OctahedralPointGeneration 
{
    points_6,
    points_12,
    points_8,
    points_24,
    points_24_axis,
    points_48
};

using OhPointGen = OctahedralPointGeneration;

/**
 * \brief Point and weight which is acted on by Octahedral symmetry group to 
 * generate sets of points in a particular Lebedev quadrature rule.
 *
 * Here is some more stuff, blah blah blah.
 */
class GeneratorPoint
{
public:

    /**
     * \brief Given point with coordinates (`a`, `b`, `c`) and a 
     * `generating_rule` which describes the action of the octahedral group
     * on this point, create a `GeneratorPoint` object which can be used to
     * generate a subset of Lebedev quadrature points.
     */
    GeneratorPoint (double a, 
                    double b, 
                    double c, 
                    double weight, 
                    OhPointGen generating_rule)
        : a(a), b(b), c(c), weight(weight), generating_rule(generating_rule)
    {}

    /**
     * \brief Generates quadrature points via action of the Octahedral symmetry
     * group and then appends points and weight to `x`, `y`, `z`, and `w` 
     * vectors.
     */
    void generate_quadrature_points(vec &x, vec &y, vec &z, vec &w) const;

private:
    /* \brief x-component of generating point */
    double a = 1.0;
    /* \brief y-component of generating point */
    double b = 0.0;
    /* \brief z-component of generating point */
    double c = 0.0;
    /* \brief quadrature weight of all quadrature points generated by this point */
    double weight = 0.1666666666666667;
    
    /* \brief rule which describes action of the octahedral group on this point */
    OhPointGen generating_rule = OhPointGen::points_6;
};



template <OctahedralPointGeneration>
void generate_oh_symmetric_points
(double a, double b, double c,vec &x, vec &y, vec &z);



template <>
inline void 
generate_oh_symmetric_points<OctahedralPointGeneration::points_6>
(double a, double b, double c, vec &x, vec &y, vec &z) 
{

    assert((a == 1) && (b == 0) && (c == 0) 
            && "6 point symmetry must have one nonzero component");

    x.insert(x.end(), { a, -a,  0,  0,  0,  0});
    y.insert(y.end(), { 0,  0,  a, -a,  0,  0});
    z.insert(z.end(), { 0,  0,  0,  0,  a, -a});
}



template <>
inline void 
generate_oh_symmetric_points<OctahedralPointGeneration::points_12>
(double a, double b, double c, vec &x, vec &y, vec &z)
{

    assert((b == 0) && (c == 0)
           && "12 point symmetry has two components which are the same");

    x.insert(x.end(), { 0,  0,  0,  0,  a, -a,  a, -a,  a, -a,  a, -a});
    y.insert(y.end(), { a, -a,  a, -a,  0,  0,  0,  0,  a,  a, -a, -a});
    z.insert(z.end(), { a,  a, -a, -a,  a,  a, -a, -a,  0,  0,  0,  0});
}



template <>
inline void 
generate_oh_symmetric_points<OctahedralPointGeneration::points_8>
(double a, double b, double c, vec &x, vec &y, vec &z)
{
    assert((b == 0) && (c == 0)
            && "8 point symmetry has all three components which are the same");

    x.insert(x.end(), { a, -a,  a, -a,  a, -a,  a, -a});
    y.insert(y.end(), { a,  a, -a, -a,  a,  a, -a, -a});
    z.insert(z.end(), { a,  a,  a,  a, -a, -a, -a, -a});
}



template <>
inline void 
generate_oh_symmetric_points<OctahedralPointGeneration::points_24>
(double a, double b, double c, vec &x, vec &y, vec &z)
{
    assert((c == 0)
            && "24 points symmetry has form (a, a, b), so c = 0");
    
    x.insert(x.end(), { a, -a,  a, -a,  a, -a,  a, -a,  a, -a,  a, -a});
    y.insert(y.end(), { a,  a, -a, -a,  a,  a, -a, -a,  b,  b, -b, -b});
    z.insert(z.end(), { b,  b,  b,  b, -b, -b, -b, -b,  a,  a,  a,  a});

    x.insert(x.end(), { a, -a,  a, -a,  b, -b,  b, -b,  b, -b,  b, -b});
    y.insert(y.end(), { b,  b, -b, -b,  a,  a, -a, -a,  a,  a, -a, -a});
    z.insert(z.end(), {-a, -a, -a, -a,  a,  a,  a,  a, -a, -a, -a, -a});
}



template <>
inline void 
generate_oh_symmetric_points<OctahedralPointGeneration::points_24_axis>
(double a, double b, double c, vec &x, vec &y, vec &z)
{
    assert((c == 0)
            && "24 points symmetry (axis) has form (a, b, 0), so c = 0");

    x.insert(x.end(), { a, -a,  a, -a,  b, -b,  b, -b,  a, -a,  a, -a});
    y.insert(y.end(), { b,  b, -b, -b,  a,  a, -a, -a,  0,  0,  0,  0});
    z.insert(z.end(), { 0,  0,  0,  0,  0,  0,  0,  0,  b,  b, -b, -b});

    x.insert(x.end(), { b, -b,  b, -b,  0,  0,  0,  0,  0,  0,  0,  0});
    y.insert(y.end(), { 0,  0,  0,  0,  a, -a,  a, -a,  b, -b,  b, -b});
    z.insert(z.end(), { a,  a, -a, -a,  b,  b, -b, -b,  a,  a, -a, -a});
}



template <>
inline void
generate_oh_symmetric_points<OctahedralPointGeneration::points_48>
(double a, double b, double c, vec &x, vec &y, vec &z)
{
    x.insert(x.end(), { a, -a,  a, -a,  a, -a,  a, -a,  a, -a,  a, -a});
    y.insert(y.end(), { b,  b, -b, -b,  b,  b, -b, -b,  c,  c, -c, -c});
    z.insert(z.end(), { c,  c,  c,  c, -c, -c, -c, -c,  b,  b,  b,  b});

    x.insert(x.end(), { a, -a,  a, -a,  b, -b,  b, -b,  b, -b,  b, -b});
    y.insert(y.end(), { c,  c, -c, -c,  a,  a, -a, -a,  a,  a, -a, -a});
    z.insert(z.end(), {-b, -b, -b, -b,  c,  c,  c,  c, -c, -c, -c, -c});

    x.insert(x.end(), { b, -b,  b, -b,  b, -b,  b, -b,  c, -c,  c, -c});
    y.insert(y.end(), { c,  c, -c, -c,  c,  c, -c, -c,  a,  a, -a, -a});
    z.insert(z.end(), { a,  a,  a,  a, -a, -a, -a, -a,  b,  b,  b,  b});

    x.insert(x.end(), { c, -c,  c, -c,  c, -c,  c, -c,  c, -c,  c, -c});
    y.insert(y.end(), { a,  a, -a, -a,  b,  b, -b, -b,  b,  b, -b, -b});
    z.insert(z.end(), {-b, -b, -b, -b,  a,  a,  a,  a, -a, -a, -a, -a});
}




inline void GeneratorPoint::
generate_quadrature_points(vec &x, vec &y, vec &z, vec &w) const
{
    unsigned int n_points = 0;
    if (generating_rule == OhPointGen::points_6)
    {
        generate_oh_symmetric_points<OhPointGen::points_6> (a, b, c, x, y, z);
        n_points = 6;
    } else if (generating_rule == OhPointGen::points_12)
    {
        generate_oh_symmetric_points<OhPointGen::points_12> (a, b, c, x, y, z);
        n_points = 12;
    } else if (generating_rule == OhPointGen::points_8)
    {
        generate_oh_symmetric_points<OhPointGen::points_8> (a, b, c, x, y, z);
        n_points = 8;
    } else if (generating_rule == OhPointGen::points_24)
    {
        generate_oh_symmetric_points<OhPointGen::points_24> (a, b, c, x, y, z);
        n_points = 24;
    } else if (generating_rule == OhPointGen::points_24_axis)
    {
        generate_oh_symmetric_points<OhPointGen::points_24_axis> (a, b, c, x, y, z);
        n_points = 24;
    } else if (generating_rule == OhPointGen::points_48)
    {
        generate_oh_symmetric_points<OhPointGen::points_48> (a, b, c, x, y, z);
        n_points = 48;
    } else 
    {
        throw std::invalid_argument("Not a valid octahedral generating rule");
    }
    w.insert(w.end(), n_points, weight);
}

} // namespace lebedev

#endif
